from __future__ import annotations
import copy
import json
import logging
import os
from pathlib import Path
from typing import Any, Callable, Dict, Iterable, List, Mapping, MutableMapping, Optional, Tuple

from mutants.bootstrap import lazyinit
from mutants.constants import CLASS_ORDER
from mutants.io.atomic import atomic_write_json
from mutants.players import startup as player_startup
from mutants.registries import items_instances as itemsreg
from mutants.state import state_path
from mutants.services import monsters_state, state_debug
from .equip_debug import _edbg_enabled, _edbg_log


LOG = logging.getLogger(__name__)
LOG_P = logging.getLogger("mutants.playersdbg")

CANONICAL_CLASSES = tuple(CLASS_ORDER)


_PDBG_CONFIGURED = False
_ACTIVE_SNAPSHOT_WARNING_EMITTED = False
_AUTOSAVE_WARNING_EMITTED = False

_STARTING_TEMPLATES_CACHE: Dict[str, Dict[str, Any]] | None = None

# Canonical on-disk schema (no transient ``active`` snapshot):
# {
#   "players": [
#       {"id": "player_thief", "class": "Thief", "pos": [2000, 0, 0], ...},
#       ...
#   ],
#   "active_id": "player-id-or-null",
#   "ions_by_class": {"Thief": 30000, ...},
#   ...
# }


DEFAULT_PLAYER_DISPLAY_NAME = "Vindeiatrix"


_RUNTIME_PLAYER_KEY = "_runtime_player"


def _active_player_from_state(state: Mapping[str, Any]) -> Dict[str, Any]:
    """Return the active player mapping from ``state``."""

    if not isinstance(state, Mapping):
        return {}

    players = state.get("players")
    active_id = state.get("active_id")
    if isinstance(players, list) and players:
        if active_id is not None:
            for player in players:
                if isinstance(player, MutableMapping) and player.get("id") == active_id:
                    return player  # type: ignore[return-value]
        first = players[0]
        if isinstance(first, MutableMapping):
            return first  # type: ignore[return-value]

    return {}


def _load_player_from_disk() -> Dict[str, Any]:
    """Load and return the active player mapping from disk."""

    state = load_state()
    player = _active_player_from_state(state)
    if isinstance(player, MutableMapping):
        player.setdefault("_dirty", False)
        return player  # type: ignore[return-value]
    return {"_dirty": False}


def _strip_runtime_metadata(state: Mapping[str, Any]) -> Dict[str, Any]:
    """Return ``state`` copied without transient runtime markers."""

    sanitized = copy.deepcopy(state if isinstance(state, Mapping) else {})

    active = sanitized.get("active")
    if isinstance(active, MutableMapping):
        active.pop("_dirty", None)

    players = sanitized.get("players")
    if isinstance(players, list):
        for entry in players:
            if isinstance(entry, MutableMapping):
                entry.pop("_dirty", None)

    normalize_player_state_inplace(sanitized)

    return sanitized


def set_active_player(state: dict, player_id: str) -> dict:
    """Mark ``player_id`` as active and align top-level fields accordingly."""

    if not isinstance(state, MutableMapping):
        return {"players": [], "active_id": None}

    active_entry: Dict[str, Any] | None = None
    players = state.get("players")
    if isinstance(players, list):
        for entry in players:
            if not isinstance(entry, MutableMapping):
                continue
            is_match = entry.get("id") == player_id
            entry["is_active"] = is_match
            if is_match:
                active_entry = entry

    state["active_id"] = player_id

    if active_entry:
        state["class"] = active_entry.get("class")
        state["pos"] = list(active_entry.get("pos") or state.get("pos") or [2000, 0, 0])
        state["position"] = list(state.get("pos"))
        # Align ready target fields with per-class maps to avoid bleed between classes.
        cls_token = _normalize_class_name(active_entry.get("class"))
        ready_map = state.get("ready_target_by_class") if isinstance(state, MutableMapping) else None
        target_map = state.get("target_monster_id_by_class") if isinstance(state, MutableMapping) else None
        per_class_ready = None
        per_class_target = None
        if isinstance(ready_map, Mapping) and cls_token in ready_map:
            per_class_ready = ready_map.get(cls_token)
        if isinstance(target_map, Mapping) and cls_token in target_map:
            per_class_target = target_map.get(cls_token)
        active_entry["ready_target"] = per_class_ready
        active_entry["target_monster_id"] = per_class_target
        state["ready_target"] = per_class_ready
        state["target_monster_id"] = per_class_target

        # Keep the active inventory bound to the active class' bag instead of
        # leaking whatever bag happened to be in ``state['inventory']`` when
        # switching characters.
        bags = state.get("bags") if isinstance(state.get("bags"), Mapping) else None
        class_name = _normalize_class_name(active_entry.get("class")) or _normalize_class_name(
            active_entry.get("name")
        )
        bag: List[str] = []
        if isinstance(bags, MutableMapping) and class_name:
            raw_bag = bags.get(class_name)
            if isinstance(raw_bag, list):
                bag = [item for item in raw_bag if item is not None]
        if not bag:
            raw_inv = active_entry.get("inventory")
            if isinstance(raw_inv, list):
                bag = [item for item in raw_inv if item is not None]
        if isinstance(bags, MutableMapping) and class_name:
            bags[class_name] = list(bag)
        state["inventory"] = list(bag)
        active_entry["inventory"] = list(bag)

    return state


def normalize_player_live_state(data: dict) -> Dict[str, Any]:
    """Normalize on-disk player live state in-place and drop snapshots."""

    if not isinstance(data, Mapping):
        return {"players": [], "active_id": None}

    normalized: Dict[str, Any] = copy.deepcopy(dict(data))

    active_payload = normalized.get("active")
    if isinstance(active_payload, Mapping):
        global _ACTIVE_SNAPSHOT_WARNING_EMITTED
        if not _ACTIVE_SNAPSHOT_WARNING_EMITTED:
            LOG.warning("player_state contains forbidden 'active' snapshot; stripping")
            _ACTIVE_SNAPSHOT_WARNING_EMITTED = True

    normalized.pop("active", None)

    raw_players = normalized.get("players")
    ions_lookup = normalized.get("ions_by_class") if isinstance(normalized.get("ions_by_class"), Mapping) else None
    cleaned_players: List[Dict[str, Any]] = []
    used_ids: set[str] = set()
    if isinstance(raw_players, list):
        for entry in raw_players:
            if not isinstance(entry, Mapping):
                continue
            class_token = _normalize_class_name(entry.get("class")) or _normalize_class_name(entry.get("name"))
            if not class_token:
                continue

            sanitized_entry = _sanitize_player_entry(entry, class_token, used_ids, ions_lookup)
            allowed_keys = {"id", "class", "name", "display_name", "pos", "inventory", "is_active", "ions", "Ions"}
            cleaned = {key: value for key, value in sanitized_entry.items() if key in allowed_keys}
            if "display_name" in cleaned and "name" not in cleaned:
                cleaned["name"] = cleaned["display_name"]
            cleaned_players.append(cleaned)

    normalized["players"] = cleaned_players

    active_id = _sanitize_player_id(normalized.get("active_id"))
    valid_ids = [entry.get("id") for entry in cleaned_players if isinstance(entry, Mapping) and isinstance(entry.get("id"), str)]
    if active_id not in valid_ids:
        resolved: Optional[str] = None
        for class_name in CANONICAL_CLASSES:
            for entry in cleaned_players:
                if entry.get("class") == class_name and isinstance(entry.get("id"), str):
                    resolved = entry["id"]
                    break
            if resolved:
                break

        if resolved is None and valid_ids:
            resolved = valid_ids[0]

        active_id = resolved

    normalized["active_id"] = active_id
    return normalized


def _ensure_players_list(state: MutableMapping[str, Any]) -> List[Dict[str, Any]]:
    players = state.get("players")
    if isinstance(players, list):
        sanitized: List[Dict[str, Any]] = [p for p in players if isinstance(p, MutableMapping)]
        if len(sanitized) != len(players):
            state["players"] = sanitized
        return sanitized
    state["players"] = []
    return state["players"]  # type: ignore[return-value]


def _load_starting_templates() -> Dict[str, Dict[str, Any]]:
    global _STARTING_TEMPLATES_CACHE
    if _STARTING_TEMPLATES_CACHE is not None:
        return _STARTING_TEMPLATES_CACHE

    try:
        templates = lazyinit.load_templates()
    except Exception:
        data_path = Path("src/mutants/data/startingclasstemplates.json")
        templates = json.loads(data_path.read_text(encoding="utf-8"))

    mapping: Dict[str, Dict[str, Any]] = {}
    for entry in templates:
        if not isinstance(entry, Mapping):
            continue
        cls_token = str(entry.get("class") or "").strip()
        if not cls_token:
            continue
        mapping[cls_token.lower()] = dict(entry)

    _STARTING_TEMPLATES_CACHE = mapping
    return mapping


def _get_starting_template(class_name: str) -> Dict[str, Any]:
    templates = _load_starting_templates()
    token = str(class_name or "").strip().lower()
    template = templates.get(token)
    if template is None:
        raise KeyError(f"No starting template for class: {class_name}")
    return copy.deepcopy(template)


def _allocate_player_id(used_ids: set[str], class_name: str) -> str:
    base = f"player_{class_name.lower()}" if class_name else "player"
    candidate = base
    suffix = 2
    while candidate in used_ids:
        candidate = f"{base}_{suffix}"
        suffix += 1
    used_ids.add(candidate)
    return candidate


def _coerce_pos_list(value: Any) -> List[int]:
    if isinstance(value, (list, tuple)) and len(value) == 3:
        try:
            return [int(value[0]), int(value[1]), int(value[2])]
        except (TypeError, ValueError):
            pass
    return [2000, 0, 0]


def _sanitize_player_entry(
    entry: Mapping[str, Any] | None,
    class_name: str,
    used_ids: set[str],
    ions_lookup: Mapping[str, Any] | None,
) -> Dict[str, Any]:
    if isinstance(entry, Mapping):
        sanitized: Dict[str, Any] = copy.deepcopy(dict(entry))
    else:
        sanitized = {}

    sanitized["class"] = class_name
    name_val = sanitized.get("name") or sanitized.get("display_name")
    if not isinstance(name_val, str) or not name_val.strip():
        sanitized["name"] = class_name

    sanitized["pos"] = _coerce_pos_list(sanitized.get("pos"))

    inventory = sanitized.get("inventory")
    if not isinstance(inventory, list):
        sanitized["inventory"] = []

    ions_val = sanitized.get("ions")
    if ions_val is None:
        ions_val = sanitized.get("Ions")
    if ions_val is None and isinstance(ions_lookup, Mapping):
        ions_val = ions_lookup.get(class_name)
    if ions_val is None:
        ions_val = player_startup.START_IONS.get("fresh", 30_000)
    sanitized["ions"] = int(ions_val)
    sanitized["Ions"] = int(ions_val)

    player_id = _sanitize_player_id(sanitized.get("id"))
    if not player_id or player_id in used_ids:
        sanitized["id"] = _allocate_player_id(used_ids, class_name)
    else:
        used_ids.add(player_id)

    sanitized["is_active"] = False
    return sanitized


def _build_profile_for_class(
    class_name: str, used_ids: set[str], ions_lookup: Mapping[str, Any] | None
) -> Dict[str, Any]:
    try:
        template = _get_starting_template(class_name)
    except KeyError:
        template = {"class": class_name}

    profile = lazyinit.make_player_from_template(template, make_active=False)
    if not isinstance(profile, MutableMapping):
        profile = {"class": class_name}

    sanitized = _sanitize_player_entry(profile, class_name, used_ids, ions_lookup)
    return sanitized


def ensure_class_profiles(state: MutableMapping[str, Any]) -> Dict[str, Any]:
    if not isinstance(state, MutableMapping):
        return {"players": [], "active_id": None}

    players = state.get("players")
    existing_ions_map = state.get("ions_by_class") if isinstance(state.get("ions_by_class"), Mapping) else None

    if isinstance(players, list):
        raw_players = [p for p in players if isinstance(p, Mapping)]
    else:
        raw_players = []

    by_class: Dict[str, List[Mapping[str, Any]]] = {cls: [] for cls in CANONICAL_CLASSES}
    for entry in raw_players:
        cls_token = _normalize_class_name(entry.get("class")) or _normalize_class_name(
            entry.get("name")
        )
        if cls_token and cls_token in by_class:
            by_class[cls_token].append(entry)

    used_ids: set[str] = set()
    sanitized_players: List[Dict[str, Any]] = []

    active_id = _sanitize_player_id(state.get("active_id"))
    active_snapshot = state.get("active")
    snapshot_class = None
    if isinstance(active_snapshot, Mapping):
        snapshot_class = _normalize_class_name(active_snapshot.get("class")) or _normalize_class_name(
            active_snapshot.get("name")
        )
    root_class = _normalize_class_name(state.get("class")) or _normalize_class_name(
        state.get("name")
    )

    for class_name in CANONICAL_CLASSES:
        candidates = by_class.get(class_name, [])
        chosen: Mapping[str, Any] | None = None
        if active_id:
            for entry in candidates:
                if _sanitize_player_id(entry.get("id")) == active_id:
                    chosen = entry
                    break
        if chosen is None and candidates:
            chosen = candidates[0]
        if chosen is None:
            sanitized_players.append(_build_profile_for_class(class_name, used_ids, existing_ions_map))
        else:
            sanitized_players.append(
                _sanitize_player_entry(chosen, class_name, used_ids, existing_ions_map)
            )

    state["players"] = sanitized_players

    ions_map = state.get("ions_by_class")
    if isinstance(ions_map, MutableMapping):
        for key in list(ions_map.keys()):
            if key not in CANONICAL_CLASSES:
                ions_map.pop(key)
    else:
        ions_map = {}
        state["ions_by_class"] = ions_map

    resolved_active_id = None
    if active_id:
        for entry in sanitized_players:
            if _sanitize_player_id(entry.get("id")) == active_id:
                resolved_active_id = entry["id"]
                break

    if resolved_active_id is None:
        preferred_class = snapshot_class or root_class or CANONICAL_CLASSES[0]
        for entry in sanitized_players:
            if entry.get("class") == preferred_class:
                resolved_active_id = entry["id"]
                break

    if resolved_active_id is None and sanitized_players:
        resolved_active_id = sanitized_players[0]["id"]

    state["active_id"] = resolved_active_id

    active_player: Optional[Dict[str, Any]] = None
    for entry in sanitized_players:
        is_active = bool(resolved_active_id and entry.get("id") == resolved_active_id)
        entry["is_active"] = is_active
        if is_active:
            active_player = entry
        ions_map[entry["class"]] = int(entry.get("ions", 0))

    if active_player:
        state["class"] = active_player.get("class")
        if isinstance(active_player.get("name"), str):
            state["name"] = active_player["name"]

    return state


def _canonical_class_token(state: Mapping[str, Any], class_name: Any) -> str:
    token = _normalize_class_name(class_name)
    if token:
        return token

    players = state.get("players")
    active_id = _sanitize_player_id(state.get("active_id"))
    if isinstance(players, list) and active_id:
        for entry in players:
            if not isinstance(entry, Mapping):
                continue
            if _sanitize_player_id(entry.get("id")) == active_id:
                candidate = _normalize_class_name(entry.get("class")) or _normalize_class_name(
                    entry.get("name")
                )
                if candidate:
                    return candidate
                break

    if isinstance(players, list):
        for entry in players:
            if not isinstance(entry, Mapping):
                continue
            candidate = _normalize_class_name(entry.get("class")) or _normalize_class_name(
                entry.get("name")
            )
            if candidate:
                return candidate

    return "Thief"


def _generate_unique_player_id(players: Iterable[Mapping[str, Any]], class_token: str) -> str:
    base = f"player_{class_token.lower()}" if class_token else "player"
    existing = {
        token
        for token in (
            _sanitize_player_id(entry.get("id"))
            for entry in players
            if isinstance(entry, Mapping)
        )
        if token
    }
    candidate = base
    suffix = 2
    while candidate in existing:
        candidate = f"{base}_{suffix}"
        suffix += 1
    return candidate


def _ensure_player_entry(state: MutableMapping[str, Any], class_name: Any) -> Dict[str, Any]:
    players = _ensure_players_list(state)
    class_token = _canonical_class_token(state, class_name)

    active_id = _sanitize_player_id(state.get("active_id"))
    if active_id:
        for entry in players:
            if not isinstance(entry, MutableMapping):
                continue
            if _sanitize_player_id(entry.get("id")) != active_id:
                continue
            entry_class = _normalize_class_name(entry.get("class")) or _normalize_class_name(entry.get("name"))
            if entry_class == class_token or class_token == "Thief":
                return entry  # type: ignore[return-value]
            break

    for entry in players:
        if not isinstance(entry, MutableMapping):
            continue
        entry_class = _normalize_class_name(entry.get("class")) or _normalize_class_name(entry.get("name"))
        if entry_class == class_token:
            return entry  # type: ignore[return-value]

    if players:
        first = players[0]
        if isinstance(first, MutableMapping):
            return first  # type: ignore[return-value]

    new_entry: Dict[str, Any] = {
        "id": _generate_unique_player_id(players, class_token),
        "class": class_token,
        "name": class_token,
        "pos": [2000, 0, 0],
        "inventory": [],
    }
    players.append(new_entry)
    if not _sanitize_player_id(state.get("active_id")):
        state["active_id"] = new_entry["id"]
    return new_entry


def get_canonical_state(state: Optional[Mapping[str, Any]] = None) -> Dict[str, Any]:
    """Return ``state`` coerced into canonical on-disk form."""

    if isinstance(state, Mapping):
        base = copy.deepcopy(dict(state))
    else:
        base = {}

    if base:
        base = migrate_per_class_fields(base)
    else:
        base = {"players": [], "active_id": None}

    normalize_player_state_inplace(base)
    base.pop("active", None)

    ensure_class_profiles(base)

    players = base.get("players")
    if not isinstance(players, list):
        base["players"] = []
    ions_map = base.get("ions_by_class")
    if not isinstance(ions_map, dict):
        base["ions_by_class"] = {}
    base.setdefault("active_id", None)
    return base


def update_player_pos(
    state: MutableMapping[str, Any], class_name: Any, pos: Iterable[Any]
) -> List[int]:
    """Update the canonical position for ``class_name`` within ``state``."""

    entry = _ensure_player_entry(state, class_name)
    coords = _coerce_pos(pos)
    if coords is None:
        return entry.get("pos", [2000, 0, 0])  # type: ignore[return-value]

    year, x, y = coords
    entry["pos"] = [int(year), int(x), int(y)]

    active_id = _sanitize_player_id(state.get("active_id"))
    if active_id and _sanitize_player_id(entry.get("id")) == active_id:
        state["pos"] = list(entry["pos"])
        state["position"] = list(entry["pos"])

    return list(entry["pos"])  # type: ignore[return-value]


def move_player(
    state: MutableMapping[str, Any], class_name: Any, delta: Iterable[Any]
) -> List[int]:
    """Apply ``delta`` to the canonical position for ``class_name``."""

    try:
        raw_delta = list(delta)
    except Exception:
        raw_delta = []

    if len(raw_delta) < 3:
        raw_delta = list(raw_delta) + [0] * (3 - len(raw_delta))
    try:
        d_year = int(raw_delta[0])
    except Exception:
        d_year = 0
    try:
        d_x = int(raw_delta[1])
    except Exception:
        d_x = 0
    try:
        d_y = int(raw_delta[2])
    except Exception:
        d_y = 0

    year, x, y = canonical_player_pos(state)
    new_pos = (year + d_year, x + d_x, y + d_y)
    return update_player_pos(state, class_name, new_pos)


def sync_runtime_position(ctx: MutableMapping[str, Any], pos: Iterable[Any]) -> None:
    """Update in-memory views of the active player's position."""

    coords = list(pos)
    while len(coords) < 3:
        coords.append(0)
    canonical = [int(coords[0]), int(coords[1]), int(coords[2])]

    state_hint = ctx.get("player_state") if isinstance(ctx, MutableMapping) else None
    if isinstance(state_hint, MutableMapping):
        state_hint["pos"] = list(canonical)
        state_hint["position"] = list(canonical)
        players = state_hint.get("players")
        active_id = state_hint.get("active_id")
        if isinstance(players, list):
            target = None
            if active_id is not None:
                for entry in players:
                    if isinstance(entry, MutableMapping) and entry.get("id") == active_id:
                        target = entry
                        break
            if target is None and players:
                candidate = players[0]
                target = candidate if isinstance(candidate, MutableMapping) else None
            if isinstance(target, MutableMapping):
                target["pos"] = list(canonical)
                target["position"] = list(canonical)
        active_view = state_hint.get("active")
        if isinstance(active_view, MutableMapping):
            active_view["pos"] = list(canonical)
            active_view["position"] = list(canonical)

    runtime = ctx.get("_runtime_player") if isinstance(ctx, MutableMapping) else None
    if isinstance(runtime, MutableMapping):
        runtime["pos"] = list(canonical)
        runtime["position"] = list(canonical)

    ctx["_active_view"] = {"pos": list(canonical)}


def _sanitize_inventory_list(raw_inventory: Iterable[Any]) -> List[str]:
    seen: set[str] = set()
    sanitized: List[str] = []
    for item in raw_inventory or []:
        token = copy.deepcopy(item)
        if token is None:
            continue
        try:
            token_str = str(token)
        except Exception:
            continue
        if token_str and token_str not in seen:
            seen.add(token_str)
            sanitized.append(token_str)
    return sanitized


def update_player_inventory(
    state: MutableMapping[str, Any], class_name: Any, inventory_delta: Iterable[Any]
) -> List[Any]:
    """Bind ``inventory_delta`` to the canonical profile for ``class_name``."""

    entry = _ensure_player_entry(state, class_name)
    sanitized = _sanitize_inventory_list(inventory_delta)
    entry["inventory"] = list(sanitized)

    class_token = _canonical_class_token(state, class_name)
    bags = state.setdefault("bags", {}) if isinstance(state, MutableMapping) else None
    if isinstance(bags, MutableMapping):
        bags[class_token] = list(sanitized)

    active_id = _sanitize_player_id(state.get("active_id"))
    if active_id and _sanitize_player_id(entry.get("id")) == active_id:
        state["inventory"] = list(sanitized)

    active_view = state.get("active") if isinstance(state, MutableMapping) else None
    if isinstance(active_view, MutableMapping):
        active_view.setdefault("bags", {})
        active_view["inventory"] = list(sanitized)
        active_view.get("bags", {})[class_token] = list(sanitized)

    return list(sanitized)


def add_item_to_active_inventory(state: dict, player: dict, iid: str) -> None:
    """Add ``iid`` to the active player's inventory and canonical bag."""

    cls = player.get("class") or get_active_class(state)
    inv = _sanitize_inventory_list(player.get("inventory") or [])
    if iid not in inv:
        inv.append(iid)
    player["inventory"] = list(inv)

    bags = state.setdefault("bags", {})
    bags.setdefault(cls, [])
    if iid not in bags[cls]:
        bags[cls].append(iid)

    update_player_inventory(state, cls, inv)



def _save_player_to_disk(state: Mapping[str, Any]) -> None:
    """Persist ``state`` to disk using the canonical saver."""

    save_state(dict(state))


def _current_runtime_ctx() -> MutableMapping[str, Any] | None:
    """Return the current runtime context if available."""

    try:
        from mutants.app import context as app_context

        ctx = app_context.current_context()
    except Exception:
        return None

    return ctx if isinstance(ctx, MutableMapping) else None


def _refresh_runtime_player(state: Mapping[str, Any]) -> None:
    """Refresh the runtime player cache using ``state`` when available."""

    ctx = _current_runtime_ctx()
    if isinstance(ctx, MutableMapping):
        ctx["player_state"] = dict(state)
        ctx.pop(_RUNTIME_PLAYER_KEY, None)
        runtime_player = ensure_player_state(ctx)
        bind_inventory_to_active_class(runtime_player)


def ensure_player_state(ctx: MutableMapping[str, Any]) -> Dict[str, Any]:
    """Return the runtime player for ``ctx``, loading it if required."""

    if not isinstance(ctx, MutableMapping):
        return _load_player_from_disk()

    cached = ctx.get(_RUNTIME_PLAYER_KEY)
    state_hint = ctx.get("player_state")
    if isinstance(cached, MutableMapping) and isinstance(state_hint, Mapping):
        # Drop stale runtime caches when the active player in ``state_hint``
        # differs from the cached snapshot. This keeps session transitions
        # (e.g., switching classes) isolated and prevents writes for the
        # wrong character.
        cached_id = cached.get("id")
        hinted_id = state_hint.get("active_id")
        cached_cls = _normalize_class_name(cached.get("class"))
        hinted_cls = _normalize_class_name(state_hint.get("class"))
        if (hinted_id and cached_id != hinted_id) or (hinted_cls and cached_cls != hinted_cls):
            ctx.pop(_RUNTIME_PLAYER_KEY, None)
            cached = None

    if isinstance(cached, MutableMapping):
        cached.setdefault("_dirty", False)
        return cached  # type: ignore[return-value]

    if not isinstance(state_hint, MutableMapping):
        state_hint = load_state()
        ctx["player_state"] = state_hint
    else:
        normalize_player_state_inplace(state_hint)

    active_view = build_active_view(state_hint if isinstance(state_hint, MutableMapping) else {})
    if isinstance(state_hint, MutableMapping) and active_view:
        state_hint["active"] = active_view

    active_player = _active_player_from_state(state_hint)
    if not isinstance(active_player, MutableMapping):
        active_player = {}
        state_hint["active"] = active_player

    active_player.setdefault("_dirty", False)
    ctx[_RUNTIME_PLAYER_KEY] = active_player
    return active_player  # type: ignore[return-value]


def canonical_player_pos(p) -> tuple[int, int, int]:
    """Return (year, x, y) from the active player entry."""

    aid = (p or {}).get("active_id")
    for pl in (p or {}).get("players") or []:
        if isinstance(pl, dict) and pl.get("id") == aid:
            pos = pl.get("pos") or pl.get("position")
            if pos:
                return int(pos[0]), int(pos[1]), int(pos[2])

    pos = ((p or {}).get("pos") or (p or {}).get("position") or (2000, 0, 0))
    return int(pos[0]), int(pos[1]), int(pos[2])


def normalize_player_state_inplace(p: dict) -> dict:
    """Strip persisted snapshots; keep only canonical fields."""

    if not isinstance(p, dict):
        return p

    if "active" in p:
        del p["active"]

    # Drop legacy wielded weapon fields; wielding is no longer persisted.
    for key in ("wielded", "weapon", "wielded_by_class"):
        p.pop(key, None)

    aid = p.get("active_id")
    players = p.get("players")
    if isinstance(players, list) and players:
        target: Optional[Dict[str, Any]] = None
        if aid is not None:
            for pl in players:
                if isinstance(pl, dict) and pl.get("id") == aid:
                    target = pl
                    break
        if target is None:
            first = players[0]
            target = first if isinstance(first, dict) else None

        if isinstance(target, dict):
            pos = target.get("pos") or target.get("position")
            if pos:
                y, x, z = pos
            else:
                y, x, z = canonical_player_pos(p)
            target["pos"] = [int(y), int(x), int(z)]

    if isinstance(players, list):
        for pl in players:
            if not isinstance(pl, dict):
                continue
            for key in ("wielded", "weapon", "wielded_by_class"):
                pl.pop(key, None)

    return p


def _repair_from_templates(state: MutableMapping[str, Any]) -> bool:
    """Best-effort repair for missing/zeroed stats, hp, and positions using templates."""

    changed = False
    try:
        from mutants.bootstrap import lazyinit
    except Exception:
        return False

    templates = {tpl.get("class"): tpl for tpl in lazyinit.load_templates()}
    players = state.get("players") if isinstance(state, MutableMapping) else None
    if not isinstance(players, list):
        return False

    for pl in players:
        if not isinstance(pl, MutableMapping):
            continue
        cls_name = _normalize_class_name(pl.get("class")) or _normalize_class_name(pl.get("name"))
        if not cls_name:
            continue
        template = templates.get(cls_name)
        if not isinstance(template, Mapping):
            continue
        base_stats = template.get("base_stats") or {}
        stats_block = pl.get("stats") if isinstance(pl.get("stats"), MutableMapping) else {}
        repaired_stats = dict(stats_block)
        for key, val in (base_stats or {}).items():
            try:
                cur_val = int(repaired_stats.get(key, 0))
            except Exception:
                cur_val = 0
            if cur_val <= 0:
                repaired_stats[key] = val
                changed = True
        if repaired_stats and repaired_stats != stats_block:
            pl["stats"] = repaired_stats

        hp_block = pl.get("hp") if isinstance(pl.get("hp"), MutableMapping) else {}
        try:
            hp_cur = int(hp_block.get("current", 0))
            hp_max = int(hp_block.get("max", 0))
        except Exception:
            hp_cur = hp_max = 0
        tpl_hp = int(template.get("hp_max_start", 0) or 0)
        if hp_cur <= 0 or hp_max <= 0:
            pl["hp"] = {"current": tpl_hp, "max": tpl_hp}
            changed = True

        pos = pl.get("pos") or pl.get("position")
        if not pos or len(pos) < 3:
            try:
                fallback_pos = state.get("pos") or state.get("position") or (2000, 0, 0)
            except Exception:
                fallback_pos = (2000, 0, 0)
            pl["pos"] = [int(fallback_pos[0]), int(fallback_pos[1]), int(fallback_pos[2])]
            changed = True

    return changed


def build_active_view(p: dict) -> Dict[str, Any]:
    """Build a read-only view for UI consumption; do not persist this."""

    if not isinstance(p, dict):
        return {}

    active: MutableMapping[str, Any] | None = None
    aid = p.get("active_id")
    players = p.get("players")
    if isinstance(players, list):
        for pl in players:
            if not isinstance(pl, dict):
                continue
            if aid is None or pl.get("id") == aid:
                pos = pl.get("pos") or pl.get("position")
                if pos:
                    y, x, z = pos
                    pl["pos"] = [int(y), int(x), int(z)]
                active = pl
                break

    if not isinstance(active, MutableMapping):
        active = {}

    cls = _normalize_class_name(active.get("class")) or _normalize_class_name(active.get("name"))
    if not cls:
        cls = _normalize_class_name(p.get("class"))

    def _coerce_from_map(source: Any) -> Optional[int]:
        if not cls or not isinstance(source, Mapping):
            return None
        value = source.get(cls)
        if value is None:
            return None
        try:
            return int(value)
        except (TypeError, ValueError):
            return None

    rib_from_map = _coerce_from_map(p.get("riblets_by_class"))
    if rib_from_map is not None:
        active["riblets"] = rib_from_map
        active["Riblets"] = rib_from_map

    exp_from_map = _coerce_from_map(p.get("exp_by_class"))
    if exp_from_map is not None:
        active["exp_points"] = exp_from_map

    ions_from_map = _coerce_from_map(p.get("ions_by_class"))
    if ions_from_map is not None:
        active["ions"] = ions_from_map
        active["Ions"] = ions_from_map

    if active:
        return active

    y, x, z = canonical_player_pos(p)
    return {"pos": [int(y), int(x), int(z)]}


def save_player_state(ctx: MutableMapping[str, Any]) -> None:
    """Persist the runtime player associated with ``ctx`` if dirty."""

    if not isinstance(ctx, MutableMapping):
        return

    player = ctx.get(_RUNTIME_PLAYER_KEY)
    if not isinstance(player, MutableMapping):
        return

    if not player.get("_dirty"):
        return

    state = ctx.get("player_state")
    if not isinstance(state, Mapping):
        state = load_state()

    sanitized = _strip_runtime_metadata(state)
    _save_player_to_disk(sanitized)

    ctx["player_state"] = sanitized
    active_view = build_active_view(sanitized)
    if active_view:
        sanitized["active"] = active_view
    _, refreshed_player = get_active_pair(sanitized)
    refreshed_player.setdefault("_dirty", False)
    ctx[_RUNTIME_PLAYER_KEY] = refreshed_player


def _combat_log_set(target: Optional[str], actor: Optional[str]) -> None:
    if not _pdbg_enabled() or not target:
        return
    try:
        _pdbg_setup_file_logging()
        LOG_P.info("COMBAT/SET target=%s by=%s", target, actor or "?")
    except Exception:  # pragma: no cover - debug logging
        pass


def _combat_log_clear(reason: str) -> None:
    if not _pdbg_enabled():
        return
    try:
        _pdbg_setup_file_logging()
        LOG_P.info("COMBAT/CLEAR reason=%s", reason)
    except Exception:  # pragma: no cover - debug logging
        pass

_STAT_KEYS: Tuple[str, ...] = ("str", "int", "wis", "dex", "con", "cha")
_IONS_KEYS: Tuple[str, ...] = ("ions", "Ions")
_RIBLETS_KEYS: Tuple[str, ...] = ("riblets", "Riblets")
_EXP_KEYS: Tuple[str, ...] = (
    "exp_points",
    "experience_points",
    "experience",
    "ExpPoints",
    "ExperiencePoints",
)
_LEVEL_KEYS: Tuple[str, ...] = ("level", "Level")


def _empty_stats() -> Dict[str, int]:
    return {key: 0 for key in _STAT_KEYS}


def _empty_hp() -> Dict[str, int]:
    return {"current": 0, "max": 0}


def _pdbg_setup_file_logging() -> None:
    """Send playersdbg logs to a file when debugging is enabled."""

    global _PDBG_CONFIGURED
    if _PDBG_CONFIGURED or not _pdbg_enabled():
        return
    try:
        log_dir = state_path("logs")
        log_dir.mkdir(parents=True, exist_ok=True)
        log_path = log_dir / "players_debug.log"
        if not any(
            isinstance(handler, logging.FileHandler)
            and getattr(handler, "baseFilename", None) == str(log_path)
            for handler in LOG_P.handlers
        ):
            handler = logging.FileHandler(log_path, encoding="utf-8")
            handler.setLevel(logging.INFO)
            handler.setFormatter(logging.Formatter("%(asctime)s %(name)s: %(message)s"))
            LOG_P.addHandler(handler)
        LOG_P.setLevel(logging.INFO)
        LOG_P.propagate = False
        _PDBG_CONFIGURED = True
    except Exception:  # pragma: no cover - defensive logging only
        pass


def _pdbg_enabled() -> bool:
    return bool(os.environ.get("PLAYERS_DEBUG") or os.environ.get("WORLD_DEBUG"))


def _playersdbg_log(action: str, state: Dict[str, Any]) -> None:
    if not _pdbg_enabled() or not isinstance(state, dict):
        return
    _pdbg_setup_file_logging()
    try:
        active = state.get("active")
        if not isinstance(active, dict):
            active = {}
        klass = active.get("class") or state.get("class") or "?"

        raw_inv = state.get("inventory")
        if not isinstance(raw_inv, list):
            raw_inv = active.get("inventory") if isinstance(active, dict) else None
        inventory: List[str] = [str(i) for i in raw_inv or [] if i is not None]

        ions_map: Dict[str, int] = {}
        raw_ions = state.get("ions_by_class")
        if isinstance(raw_ions, dict):
            ions_map = {
                str(name): _coerce_int(amount, 0)
                for name, amount in raw_ions.items()
                if isinstance(name, str) and name
            }

        rib_map: Dict[str, int] = {}
        raw_riblets = state.get("riblets_by_class")
        if isinstance(raw_riblets, dict):
            rib_map = {
                str(name): _coerce_int(amount, 0)
                for name, amount in raw_riblets.items()
                if isinstance(name, str) and name
            }

        active_ions = ions_map.get(klass, _coerce_int(state.get("Ions", state.get("ions")), 0))
        active_riblets = rib_map.get(klass, _coerce_int(state.get("Riblets", state.get("riblets")), 0))

        LOG_P.info(
            "[playersdbg] %s path=%s class=%s inv_iids=%s pos=%s ions=%s riblets=%s ions_map=%s riblets_map=%s",
            action,
            str(_player_path()),
            klass,
            inventory,
            active.get("pos"),
            active_ions,
            active_riblets,
            ions_map,
            rib_map,
        )
    except Exception:  # pragma: no cover - defensive logging only
        pass

def _player_path() -> Path:
    return state_path("playerlivestate.json")


def _sanitize_player_id(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        token = value.strip()
        return token or None
    try:
        token = str(value).strip()
    except Exception:
        return None
    return token or None


def _coerce_display_name(value: Any) -> Optional[str]:
    if isinstance(value, str):
        token = value.strip()
        return token or None
    return None


def _extract_display_name(payload: Mapping[str, Any] | None) -> Optional[str]:
    if not isinstance(payload, Mapping):
        return None
    for key in ("display_name", "name"):
        candidate = _coerce_display_name(payload.get(key))
        if candidate:
            return candidate
    return None


def _persist_canonical(
    state: Dict[str, Any],
    *,
    reason: str | None = None,
    on_error: Callable[[Path, str | None, BaseException], None] | None = None,
) -> None:
    """Write ``state`` to disk without mutating logging state."""

    path = _player_path()

    def _handle_error(p: Path, tmp_path: str | None, error: BaseException) -> None:
        if on_error is not None:
            on_error(p, tmp_path, error)
            return
        state_debug.log_save_failure(
            reason=reason,
            path=p,
            tmp_path=str(tmp_path) if tmp_path else None,
            error=error,
        )

    atomic_write_json(
        path,
        state,
        on_error=_handle_error,
    )


def _has_profile_payload(state: Dict[str, Any]) -> bool:
    """Return True if ``state`` appears to represent a single-player profile."""

    for key in ("active", "inventory", "bags", "class", "name", "year"):
        if key in state:
            return True
    return False


def _coerce_int(value: Any, default: int = 0) -> int:
    """Best-effort conversion of ``value`` to ``int`` with ``default`` fallback."""

    try:
        return int(value)
    except (TypeError, ValueError):
        return default


def _sanitize_class_int(value: Any, default: int) -> int:
    """Return ``value`` coerced to ``int`` honoring ``default`` domain rules."""

    sanitized = _coerce_int(value, default)
    if default <= 0:
        return max(0, sanitized)
    if default == 1:
        return max(1, sanitized)
    return sanitized


def get_player_display_name(
    state: Optional[Mapping[str, Any]] = None,
) -> str:
    """Return a best-effort display name for the active player."""

    state_mapping: Mapping[str, Any] | None
    if isinstance(state, Mapping):
        state_mapping = state
    else:
        try:
            state_mapping = load_state()
        except Exception:
            state_mapping = None

    if not isinstance(state_mapping, Mapping):
        return DEFAULT_PLAYER_DISPLAY_NAME

    players = state_mapping.get("players")
    active_id = state_mapping.get("active_id")
    if isinstance(players, list):
        active_entry: Optional[Mapping[str, Any]] = None
        if active_id is not None:
            for entry in players:
                if not isinstance(entry, Mapping):
                    continue
                if entry.get("id") == active_id:
                    active_entry = entry
                    break
        if active_entry is None and players:
            first = players[0]
            active_entry = first if isinstance(first, Mapping) else None
        if active_entry:
            name = _extract_display_name(active_entry)
            if name:
                return name
        for entry in players:
            name = _extract_display_name(entry if isinstance(entry, Mapping) else None)
            if name:
                return name

    active_block = state_mapping.get("active")
    name = _extract_display_name(active_block if isinstance(active_block, Mapping) else None)
    if name:
        return name

    name = _extract_display_name(state_mapping)
    if name:
        return name

    return DEFAULT_PLAYER_DISPLAY_NAME


def _snapshot_currency_map(payload: Any) -> Dict[str, int]:
    """Return a sanitized snapshot of a currency mapping."""

    if not isinstance(payload, dict):
        return {}
    snapshot: Dict[str, int] = {}
    for name, amount in payload.items():
        if not isinstance(name, str) or not name:
            continue
        snapshot[name] = _coerce_int(amount, 0)
    return snapshot


def _invariants_summary(state: Dict[str, Any], details: Optional[Dict[str, Any]] = None) -> str:
    """Return a compact description of critical player-state invariants."""

    active = state.get("active") if isinstance(state, dict) else {}
    if not isinstance(active, dict):
        active = {}
    klass = active.get("class") or state.get("class") or "?"
    pos = active.get("pos")

    bags = state.get("bags") if isinstance(state, dict) else None
    if isinstance(bags, dict):
        bag_counts = {
            str(name): len(contents) if isinstance(contents, list) else -1
            for name, contents in bags.items()
        }
    else:
        bag_counts = {}

    inventory = state.get("inventory") if isinstance(state, dict) else None
    if isinstance(inventory, list):
        inv_count = len(inventory)
    else:
        inv_count = -1

    ions = _snapshot_currency_map(state.get("ions_by_class") if isinstance(state, dict) else {})
    riblets = _snapshot_currency_map(state.get("riblets_by_class") if isinstance(state, dict) else {})

    map_counts: Dict[str, int] = {}
    payload = state if isinstance(state, dict) else {}
    for key in (
        "stats_by_class",
        "hp_by_class",
        "exp_by_class",
        "level_by_class",
        "ions_by_class",
        "riblets_by_class",
    ):
        value = payload.get(key) if isinstance(payload, dict) else None
        if isinstance(value, dict):
            map_counts[key] = len(value)
        else:
            map_counts[key] = 0

    if isinstance(details, dict):
        extra_counts = details.get("map_counts")
        if isinstance(extra_counts, dict):
            map_counts.update({k: int(v) for k, v in extra_counts.items()})

    return (
        f"class={klass} pos={pos} inv_count={inv_count} "
        f"bag_counts={bag_counts} ions={ions} riblets={riblets} "
        f"map_counts={map_counts}"
    )


def _check_invariants_and_log(state: Dict[str, Any], where: str) -> None:
    """Emit diagnostic logs describing whether invariants hold for ``state``."""

    if not _pdbg_enabled():
        return

    _pdbg_setup_file_logging()
    try:
        ok, details = _evaluate_invariants_with_details(state)
    except Exception as exc:
        ok = False
        details = {"error": repr(exc)}

    summary = _invariants_summary(state if isinstance(state, dict) else {}, details)
    extra = ""
    if isinstance(details, dict):
        if details.get("failure"):
            extra += f" failure={details['failure']}"
        if details.get("missing_pair"):
            missing_map, missing_class = details["missing_pair"]
            extra += f" missing={missing_map}:{missing_class}"
        if details.get("mirror_mismatch"):
            extra += f" mirror={details['mirror_mismatch']}"
        if details.get("active_mismatch"):
            extra += f" active={details['active_mismatch']}"
        if details.get("hp_violation"):
            cls_name, cur, max_val = details["hp_violation"]
            extra += f" hp={cls_name}:{cur}>{max_val}"
        if details.get("error") and "error" not in extra:
            extra += f" error={details['error']}"

    if ok:
        LOG_P.info("[playersdbg] INV-OK %s :: %s", where, summary)
    else:
        LOG_P.error("[playersdbg] INV-FAIL %s :: %s%s", where, summary, extra)


def _normalize_class_name(value: Any) -> Optional[str]:
    if isinstance(value, str) and value:
        return value
    return None


def normalize_class_name(value: Any) -> Optional[str]:
    """Public wrapper returning a sanitized class token or ``None``."""

    return _normalize_class_name(value)


def _evaluate_item_instance_invariants() -> Tuple[bool, Dict[str, Any]]:
    summary: Dict[str, Any] = {}

    try:
        snapshot = itemsreg.snapshot_instances()
    except Exception as exc:  # pragma: no cover - defensive only
        summary["error"] = repr(exc)
        return False, summary

    summary["count"] = len(snapshot)
    invalid_levels: List[str] = []
    missing_condition: List[str] = []
    stray_condition: List[str] = []

    broken_ids = {itemsreg.BROKEN_WEAPON_ID, itemsreg.BROKEN_ARMOUR_ID}

    for inst in snapshot:
        iid_raw = inst.get("instance_id") or inst.get("iid") or inst.get("item_id")
        iid = str(iid_raw) if iid_raw is not None else "<unknown>"

        try:
            level_val = int(inst.get("enchant_level", 0))
        except (TypeError, ValueError):
            level_val = -1
        if level_val < 0:
            invalid_levels.append(iid)

        item_id_raw = inst.get("item_id") or inst.get("catalog_id") or inst.get("id")
        item_id = str(item_id_raw) if item_id_raw is not None else ""
        broken = item_id in broken_ids
        has_condition = "condition" in inst

        if broken and has_condition:
            stray_condition.append(iid)
        if not broken and not has_condition:
            missing_condition.append(iid)

    if invalid_levels:
        summary["invalid_enchant_count"] = len(invalid_levels)
        summary["invalid_enchant_sample"] = invalid_levels[:5]
    if missing_condition:
        summary["missing_condition_count"] = len(missing_condition)
        summary["missing_condition_sample"] = missing_condition[:5]
    if stray_condition:
        summary["broken_condition_count"] = len(stray_condition)
        summary["broken_condition_sample"] = stray_condition[:5]

    ok = not (invalid_levels or missing_condition or stray_condition)
    return ok, summary


def _gather_class_sources(
    state: Dict[str, Any], klass: str, active: Dict[str, Any]
) -> Tuple[Iterable[str], Dict[str, Dict[str, Any]]]:
    classes: List[str] = []
    sources: Dict[str, Dict[str, Any]] = {}

    players = state.get("players")
    if isinstance(players, list):
        for player in players:
            if not isinstance(player, dict):
                continue
            candidate = (
                _normalize_class_name(player.get("class"))
                or _normalize_class_name(player.get("name"))
            )
            if not candidate:
                continue
            classes.append(candidate)

    active_class = _normalize_class_name(active.get("class")) if isinstance(active, dict) else None
    fallback_class = _normalize_class_name(klass) or active_class
    if fallback_class:
        classes.append(fallback_class)

    root_candidates = (
        _normalize_class_name(state.get("class")),
        _normalize_class_name(state.get("name")),
    )
    for candidate in root_candidates:
        if candidate:
            classes.append(candidate)

    if not classes:
        classes.append("Thief")

    unique_classes = []
    seen: set[str] = set()
    for cls_name in classes:
        if cls_name not in seen:
            unique_classes.append(cls_name)
            seen.add(cls_name)

    return unique_classes, sources


def _source_candidates_for_class(
    cls_name: str,
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
    state: Dict[str, Any],
) -> List[Dict[str, Any]]:
    candidates: List[Dict[str, Any]] = []
    primary = class_sources.get(cls_name)
    if isinstance(primary, dict):
        candidates.append(primary)
    if isinstance(active, dict) and active is not primary:
        candidates.append(active)
    if state is not primary and state is not active:
        candidates.append(state)
    return candidates


def _extract_scalar(
    sources: Iterable[Dict[str, Any]], keys: Iterable[str]
) -> Optional[Any]:
    for src in sources:
        if not isinstance(src, dict):
            continue
        for key in keys:
            if key in src:
                return src[key]
    return None


def _normalize_hp_block(payload: Any) -> Dict[str, int]:
    current = 0
    maximum = 0
    if isinstance(payload, dict):
        current = max(0, _coerce_int(payload.get("current"), 0))
        max_raw = payload.get("max")
        if max_raw is None:
            max_raw = current
        maximum = max(0, _coerce_int(max_raw, current))
        if current > maximum:
            current = maximum
    else:
        current = 0
        maximum = 0
    return {"current": current, "max": maximum}


def _normalize_stats_block(payload: Any) -> Dict[str, int]:
    normalized = _empty_stats()
    if isinstance(payload, Mapping):
        for key in _STAT_KEYS:
            normalized[key] = _coerce_int(payload.get(key), 0)
    return normalized


def _string_key(value: Any) -> Optional[str]:
    if isinstance(value, str):
        candidate = value
    elif value is None:
        return None
    else:
        try:
            candidate = str(value)
        except Exception:
            return None
    candidate = candidate.strip() if isinstance(candidate, str) else candidate
    if not candidate:
        return None
    return candidate


def _sanitize_spell_list(payload: Any) -> List[str]:
    if not isinstance(payload, list):
        return []
    deduped: List[str] = []
    seen: set[str] = set()
    for item in payload:
        if isinstance(item, str) and item:
            key = item
        elif item is None:
            continue
        else:
            key = _string_key(item) or ""
        if not key or key in seen:
            continue
        seen.add(key)
        deduped.append(key)
    return deduped


def _sanitize_spell_container(payload: Any) -> Dict[str, List[str]]:
    container: Dict[str, List[str]] = {"known": [], "prepared": []}
    if isinstance(payload, Mapping):
        container["known"] = _sanitize_spell_list(payload.get("known"))
        container["prepared"] = _sanitize_spell_list(payload.get("prepared"))
    return container


def _sanitize_effect_dict(payload: Any) -> Dict[str, Any]:
    if not isinstance(payload, Mapping):
        return {}
    sanitized: Dict[str, Any] = {}
    for key, value in payload.items():
        key_str = _string_key(key)
        if not key_str:
            continue
        sanitized[key_str] = value
    return sanitized


def _sanitize_spell_effect_entry(payload: Any) -> Dict[str, Dict[str, Any]]:
    if isinstance(payload, Mapping):
        personal_payload = payload.get("personal")
    else:
        personal_payload = None
    return {"personal": _sanitize_effect_dict(personal_payload)}


def _sanitize_world_tile_effects(payload: Any) -> Dict[str, Any]:
    return _sanitize_effect_dict(payload)


def _empty_migration_snapshot() -> Dict[str, Optional[Any]]:
    return {
        "ions": None,
        "riblets": None,
        "exp": None,
        "level": None,
        "hp": None,
        "stats": None,
        "wielded": None,
        "ready_target": None,
    }


def _capture_legacy_payload(
    snapshots: Dict[str, Dict[str, Optional[Any]]], cls_name: Optional[str], payload: Any
) -> None:
    if not cls_name or not isinstance(payload, Mapping):
        return

    snapshot = snapshots.setdefault(cls_name, _empty_migration_snapshot())

    if snapshot["ions"] is None:
        for key in _IONS_KEYS:
            if key in payload:
                snapshot["ions"] = _sanitize_class_int(payload.get(key), 0)
                break

    if snapshot["riblets"] is None:
        for key in _RIBLETS_KEYS:
            if key in payload:
                snapshot["riblets"] = _sanitize_class_int(payload.get(key), 0)
                break

    if snapshot["exp"] is None:
        for key in _EXP_KEYS:
            if key in payload:
                snapshot["exp"] = _sanitize_class_int(payload.get(key), 0)
                break

    if snapshot["level"] is None:
        for key in _LEVEL_KEYS:
            if key in payload:
                snapshot["level"] = _sanitize_class_int(payload.get(key), 1)
                break

    if snapshot["hp"] is None and "hp" in payload:
        snapshot["hp"] = _normalize_hp_block(payload.get("hp"))

    if snapshot["stats"] is None and "stats" in payload:
        stats_payload = payload.get("stats")
        if isinstance(stats_payload, Mapping):
            snapshot["stats"] = _normalize_stats_block(stats_payload)

    if snapshot["wielded"] is None:
        wield_map = payload.get("wielded_by_class")
        candidate: Any = None
        if isinstance(wield_map, Mapping):
            candidate = wield_map.get(cls_name)
        if candidate is None and "wielded" in payload:
            candidate = payload.get("wielded")
        if candidate is None and "weapon" in payload:
            candidate = payload.get("weapon")
        sanitized = _sanitize_equipped_iid(candidate)
        if sanitized:
            snapshot["wielded"] = sanitized

    if snapshot["ready_target"] is None:
        candidate: Any = None
        ready_map = payload.get("ready_target_by_class")
        if isinstance(ready_map, Mapping):
            candidate = ready_map.get(cls_name)
        target_map = payload.get("target_monster_id_by_class")
        if candidate is None and isinstance(target_map, Mapping):
            candidate = target_map.get(cls_name)
        if candidate is None and "ready_target" in payload:
            candidate = payload.get("ready_target")
        if candidate is None and "target_monster_id" in payload:
            candidate = payload.get("target_monster_id")
        sanitized_target = _sanitize_ready_target(candidate)
        if sanitized_target:
            snapshot["ready_target"] = sanitized_target


def _collect_legacy_snapshots(state: Dict[str, Any]) -> Dict[str, Dict[str, Optional[Any]]]:
    snapshots: Dict[str, Dict[str, Optional[Any]]] = {}

    players = state.get("players")
    if isinstance(players, list):
        for player in players:
            if not isinstance(player, dict):
                continue
            cls_name = (
                _normalize_class_name(player.get("class"))
                or _normalize_class_name(player.get("name"))
            )
            _capture_legacy_payload(snapshots, cls_name, player)

    active = state.get("active")
    if isinstance(active, dict):
        active_class = (
            _normalize_class_name(active.get("class"))
            or _normalize_class_name(active.get("name"))
        )
        _capture_legacy_payload(snapshots, active_class, active)

    root_class = _normalize_class_name(state.get("class")) or _normalize_class_name(
        state.get("name")
    )
    _capture_legacy_payload(snapshots, root_class, state)

    return snapshots


def _ensure_int_map(
    state: Dict[str, Any],
    key: str,
    fallback_keys: Tuple[str, ...],
    default: int,
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
    *,
    fill_missing: bool = True,
) -> Dict[str, int]:
    raw_map = state.get(key)
    normalized: Dict[str, int] = {}
    class_set = {cls for cls in classes if isinstance(cls, str) and cls}
    if isinstance(raw_map, dict):
        for name, value in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name or cls_name not in class_set:
                continue
            normalized[cls_name] = _sanitize_class_int(value, default)

    for cls_name in classes:
        candidates = _source_candidates_for_class(cls_name, class_sources, active, state)
        fallback = _extract_scalar(candidates, fallback_keys)
        has_fallback = fallback is not None
        fallback_value = _sanitize_class_int(fallback, default)

        if cls_name in normalized:
            # Trust the existing map entry; do not overwrite from fallback/legacy sources.
            normalized[cls_name] = _sanitize_class_int(normalized[cls_name], default)
            continue

        if not fill_missing:
            continue
        normalized[cls_name] = fallback_value

    state[key] = normalized
    return normalized


def _ensure_hp_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, Dict[str, int]]:
    raw_map = state.get("hp_by_class")
    normalized: Dict[str, Dict[str, int]] = {}
    if isinstance(raw_map, dict):
        for name, payload in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name:
                continue
            normalized[cls_name] = _normalize_hp_block(payload)

    for cls_name in classes:
        candidates = _source_candidates_for_class(cls_name, class_sources, active, state)
        block: Any = None
        for src in candidates:
            if not isinstance(src, dict):
                continue
            block = src.get("hp")
            if block is not None:
                break
        fallback_block = _normalize_hp_block(block)

        if cls_name in normalized:
            current_block = _normalize_hp_block(normalized[cls_name])
            if current_block == _empty_hp() and block is not None:
                normalized[cls_name] = fallback_block
            else:
                normalized[cls_name] = current_block
            continue

        normalized[cls_name] = fallback_block

    state["hp_by_class"] = normalized
    return normalized


def _ensure_stats_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, Dict[str, int]]:
    raw_map = state.get("stats_by_class")
    normalized: Dict[str, Dict[str, int]] = {}
    if isinstance(raw_map, dict):
        for name, payload in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name:
                continue
            normalized[cls_name] = _normalize_stats_block(payload)

    for cls_name in classes:
        candidates = _source_candidates_for_class(cls_name, class_sources, active, state)
        block: Any = None
        for src in candidates:
            if not isinstance(src, dict):
                continue
            block = src.get("stats")
            if block is not None:
                break
        fallback_block = _normalize_stats_block(block)

        if cls_name in normalized:
            current_block = _normalize_stats_block(normalized[cls_name])
            if current_block == _empty_stats() and block is not None:
                normalized[cls_name] = fallback_block
            else:
                normalized[cls_name] = current_block
            continue

        normalized[cls_name] = fallback_block

    state["stats_by_class"] = normalized
    return normalized


def _sanitize_equipped_iid(value: Any) -> Optional[str]:
    """Return a normalized armour instance id from assorted payload shapes."""

    if isinstance(value, str):
        stripped = value.strip()
        return stripped or None
    if isinstance(value, Mapping):
        for key in ("iid", "instance_id", "wearing", "armour", "armor"):
            candidate = value.get(key)
            sanitized = _sanitize_equipped_iid(candidate)
            if sanitized:
                return sanitized
    return None


def _sanitize_ready_target(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        token = value.strip()
        return token or None
    try:
        token = str(value).strip()
    except Exception:
        return None
    return token or None


def _sanitize_status_effect_entry(payload: Any) -> Optional[Dict[str, Any]]:
    if payload is None:
        return None
    if isinstance(payload, Mapping):
        raw_id = payload.get("status_id") or payload.get("id")
        status_id = _string_key(raw_id)
        if not status_id:
            return None
        duration_raw = payload.get("duration")
        if duration_raw is None:
            duration_raw = payload.get("turns")
        duration = max(0, _sanitize_class_int(duration_raw, 0))
        entry: Dict[str, Any] = {"status_id": status_id, "duration": duration}
        return entry
    if isinstance(payload, str):
        status_id = payload.strip()
        if not status_id:
            return None
        return {"status_id": status_id, "duration": 0}
    return None


def _sanitize_status_effect_list(payload: Any) -> List[Dict[str, Any]]:
    if isinstance(payload, list):
        entries: List[Dict[str, Any]] = []
        seen: set[tuple[str, int]] = set()
        for item in payload:
            sanitized = _sanitize_status_effect_entry(item)
            if not sanitized:
                continue
            key = (sanitized["status_id"], sanitized["duration"])
            if key in seen:
                continue
            seen.add(key)
            entries.append(sanitized)
        return entries
    sanitized = _sanitize_status_effect_entry(payload)
    return [sanitized] if sanitized else []


def _ensure_status_effects_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, List[Dict[str, Any]]]:
    raw_map = state.get("status_effects_by_class")
    normalized: Dict[str, List[Dict[str, Any]]] = {}
    class_set = {cls for cls in classes if isinstance(cls, str) and cls}
    if isinstance(raw_map, Mapping):
        for name, payload in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name or cls_name not in class_set:
                continue
            normalized[cls_name] = _sanitize_status_effect_list(payload)

    for cls_name in classes:
        if not isinstance(cls_name, str) or not cls_name:
            continue
        candidates = _source_candidates_for_class(cls_name, class_sources, active, state)
        fallback: Any = None
        for src in candidates:
            if not isinstance(src, Mapping):
                continue
            block = src.get("status_effects")
            if block is None:
                block = src.get("statuses")
            if block is not None:
                fallback = block
                break

        if cls_name in normalized:
            normalized[cls_name] = _sanitize_status_effect_list(normalized[cls_name])
            continue

        normalized[cls_name] = _sanitize_status_effect_list(fallback)

    state["status_effects_by_class"] = normalized
    return normalized


def _ensure_equipment_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, Dict[str, Optional[str]]]:
    raw_map = state.get("equipment_by_class")
    normalized: Dict[str, Dict[str, Optional[str]]] = {}
    if isinstance(raw_map, Mapping):
        for name, payload in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name:
                continue
            armour_value: Any
            if isinstance(payload, Mapping):
                armour_value = payload.get("armour")
            else:
                armour_value = payload
            normalized[cls_name] = {"armour": _sanitize_equipped_iid(armour_value)}

    for cls_name in classes:
        key = cls_name if isinstance(cls_name, str) and cls_name else None
        if not key:
            continue
        current_entry = normalized.get(key)
        current_value = (
            _sanitize_equipped_iid(current_entry.get("armour"))
            if isinstance(current_entry, Mapping)
            else None
        )
        if current_value:
            normalized[key] = {"armour": current_value}
            continue

        fallback: Optional[str] = None
        for source in _source_candidates_for_class(key, class_sources, active, state):
            if not isinstance(source, Mapping):
                continue
            eq_map = source.get("equipment_by_class")
            if isinstance(eq_map, Mapping):
                entry = eq_map.get(key)
                if isinstance(entry, Mapping):
                    fallback = _sanitize_equipped_iid(entry.get("armour"))
                else:
                    fallback = _sanitize_equipped_iid(entry)
                if fallback:
                    break
            direct = source.get("armour")
            if isinstance(direct, Mapping):
                fallback = _sanitize_equipped_iid(direct.get("wearing"))
            else:
                fallback = _sanitize_equipped_iid(direct)
            if fallback:
                break
            legacy_direct = source.get("armor")
            fallback = _sanitize_equipped_iid(legacy_direct)
            if fallback:
                break
        # Enforce invariant: equipped armour must be present in the class's bag.
        equipped = fallback
        try:
            bags_map = state.get("bags_by_class") or state.get("bags") or {}
            class_bag = list(bags_map.get(key) or [])
        except Exception:
            class_bag = []
        if equipped and equipped not in class_bag:
            equipped = None
        normalized[key] = {"armour": equipped}

    state["equipment_by_class"] = normalized
    return normalized


def _ensure_wielded_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, Optional[str]]:
    # Wielded weapons are no longer persisted in player state.
    state.pop("wielded_by_class", None)
    return {}


def _ensure_ready_target_map(
    state: Dict[str, Any],
    classes: Iterable[str],
    class_sources: Dict[str, Dict[str, Any]],
    active: Dict[str, Any],
) -> Dict[str, Optional[str]]:
    raw_map = state.get("ready_target_by_class")
    normalized: Dict[str, Optional[str]] = {}
    if isinstance(raw_map, Mapping):
        for name, value in raw_map.items():
            cls_name = _normalize_class_name(name)
            if not cls_name:
                continue
            normalized[cls_name] = _sanitize_ready_target(value)

    target_map_raw = state.get("target_monster_id_by_class")
    if isinstance(target_map_raw, Mapping):
        for name, value in target_map_raw.items():
            cls_name = _normalize_class_name(name)
            if not cls_name:
                continue
            sanitized = _sanitize_ready_target(value)
            if cls_name not in normalized or normalized.get(cls_name) is None:
                normalized[cls_name] = sanitized

    for cls_name in classes:
        key = cls_name if isinstance(cls_name, str) and cls_name else None
        if not key:
            continue
        current = _sanitize_ready_target(normalized.get(key))
        if current is None:
            alt = f"Mutant {key}"
            if alt in normalized and normalized.get(alt) is not None:
                current = _sanitize_ready_target(normalized.get(alt))
        normalized[key] = current

    sanitized_map = {
        cls_name: _sanitize_ready_target(value) for cls_name, value in normalized.items()
    }
    state["ready_target_by_class"] = sanitized_map
    state["target_monster_id_by_class"] = dict(sanitized_map)
    return sanitized_map


def _log_wield_invariants(status: str, summary: str, healed: Iterable[str]) -> None:
    return


def _enforce_wield_invariants(
    state: Dict[str, Any],
    classes: Iterable[str],
    equipment_map: Mapping[str, Mapping[str, Optional[str]]],
    wield_map: Dict[str, Optional[str]],
    *,
    active_class: str,
) -> None:
    return


def _set_armour_view(payload: Dict[str, Any], armour_iid: Optional[str]) -> None:
    if not isinstance(payload, dict):
        return
    existing = payload.get("armour")
    if isinstance(existing, Mapping):
        block = dict(existing)
    else:
        block = {}
    block["wearing"] = armour_iid
    payload["armour"] = block


def _set_wield_view(payload: Dict[str, Any], weapon_iid: Optional[str]) -> None:
    if not isinstance(payload, dict):
        return
    payload.pop("wielded", None)


def _ensure_spells_map(state: Dict[str, Any], classes: Iterable[str]) -> Dict[str, Dict[str, List[str]]]:
    raw_map = state.get("spells_by_class")
    normalized: Dict[str, Dict[str, List[str]]] = {}
    if isinstance(raw_map, Mapping):
        for name, payload in raw_map.items():
            cls_name = _string_key(name)
            if not cls_name:
                continue
            normalized[cls_name] = _sanitize_spell_container(payload)

    for cls_name in classes:
        key = cls_name if isinstance(cls_name, str) and cls_name else None
        if not key:
            continue
        if key not in normalized:
            normalized[key] = {"known": [], "prepared": []}

    state["spells_by_class"] = normalized
    return normalized


def _ensure_spell_effects_map(
    state: Dict[str, Any], classes: Iterable[str]
) -> Dict[str, Dict[str, Dict[str, Any]]]:
    raw_map = state.get("spell_effects_by_class")
    normalized: Dict[str, Dict[str, Dict[str, Any]]] = {}
    if isinstance(raw_map, Mapping):
        for name, payload in raw_map.items():
            cls_name = _string_key(name)
            if not cls_name:
                continue
            normalized[cls_name] = _sanitize_spell_effect_entry(payload)

    for cls_name in classes:
        key = cls_name if isinstance(cls_name, str) and cls_name else None
        if not key:
            continue
        entry = normalized.get(key)
        if entry is None:
            normalized[key] = {"personal": {}}
        else:
            personal = entry.get("personal")
            if not isinstance(personal, dict):
                entry["personal"] = {}

    state["spell_effects_by_class"] = normalized
    return normalized


def _apply_maps_to_profiles(
    state: Dict[str, Any],
    klass: str,
    active: Dict[str, Any],
    ions_map: Dict[str, int],
    rib_map: Dict[str, int],
    exhaustion_map: Dict[str, int],
    exp_map: Dict[str, int],
    level_map: Dict[str, int],
    hp_map: Dict[str, Dict[str, int]],
    stats_map: Dict[str, Dict[str, int]],
    equipment_map: Dict[str, Dict[str, Optional[str]]],
    ready_map: Dict[str, Optional[str]],
    status_map: Dict[str, List[Dict[str, Any]]],
) -> None:
    players = state.get("players")
    if isinstance(players, list):
        for player in players:
            if not isinstance(player, dict):
                continue
            cls_name = (
                _normalize_class_name(player.get("class"))
                or _normalize_class_name(player.get("name"))
            )
            if not cls_name:
                continue
            ion_val = ions_map.get(cls_name, 0)
            rib_val = rib_map.get(cls_name, 0)
            player["ions"] = ion_val
            player["Ions"] = ion_val
            player["riblets"] = rib_val
            player["Riblets"] = rib_val
            player["exhaustion"] = exhaustion_map.get(cls_name, 0)
            player["exp_points"] = exp_map.get(cls_name, 0)
            player["level"] = level_map.get(cls_name, 1)
            player["hp"] = dict(hp_map.get(cls_name, _empty_hp()))
            player["stats"] = dict(stats_map.get(cls_name, _empty_stats()))

            armour_entry = equipment_map.get(cls_name)
            armour_iid = None
            if isinstance(armour_entry, Mapping):
                armour_iid = _sanitize_equipped_iid(armour_entry.get("armour"))
            elif armour_entry is not None:
                armour_iid = _sanitize_equipped_iid(armour_entry)
            equipment = player.setdefault("equipment_by_class", {})
            if isinstance(equipment, dict):
                equipment[cls_name] = {"armour": armour_iid}
            _set_armour_view(player, armour_iid)

            ready_target = _sanitize_ready_target(ready_map.get(cls_name))
            ready_map_entry = player.setdefault("ready_target_by_class", {})
            if isinstance(ready_map_entry, dict):
                ready_map_entry[cls_name] = ready_target
            target_map_entry = player.setdefault("target_monster_id_by_class", {})
            if isinstance(target_map_entry, dict):
                target_map_entry[cls_name] = ready_target
